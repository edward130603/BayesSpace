---
title: "BayesSpace"
author: "Edward Zhao, Xing Ren, Matt Stone, and Raphael Gottardo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BayesSpace}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
suppressMessages(library(SingleCellExperiment))
library(BayesSpace)
library(ggplot2)
```

## Preprocessing

We'll obtain one of the melanoma samples from the 2018 Spatial Transcriptomics
paper for this example.
```{r download}
sce <- getRDS(dataset="2018_thrane_melanoma", sample="ST_mel1_rep2")
```

Our processed datasets already include PCs, but in general it's necessary to
preprocess samples by running PCA. We recommend running PCA on only the top
highly variable genes.
```{r preprocess}
set.seed(102)
dec <- scran::modelGeneVar(sce)
top <- scran::getTopHVGs(dec, n=2000)
sce <- scater::runPCA(sce, subset_row=top)
```

## Clustering
The `spatialCluster()` function will cluster the spots, and add the predicted
cluster labels to `colData(sce)`.
```{r cluster}
set.seed(149)
sce <- spatialCluster(sce, q=4, init.method="mclust", model="t", nrep=1000, 
                      position.cols=c("col", "row"), radius=1, save.chain=TRUE)
```

We can plot the cluster assignments over the spatial locations of the spots.
```{r cluster.plot, fig.width=7, fig.height=5}
ggplot(as.data.frame(colData(sce)), aes(x = col, y = row, fill = factor(spatial.cluster))) +
  geom_point(size = 7, pch = 22) +
  labs(x = NULL, y = NULL, fill = "Cluster") +
  scale_fill_manual(values = c("purple", "red", "blue", "yellow")) +
  theme_void() + 
  coord_fixed()
```

## Enhanced resolution

The `spatialEnhance()` function will enhance the resolution of the principal
components, and add these PCs as well as predicted cluster labels at subspot
resolution to a new SingleCellExperiment.
```{r enhance, eval=TRUE}
enhanced <- spatialEnhance(sce, q=4, init=sce$spatial.cluster, model="t", nrep=1000, 
                           position.cols=c("col", "row"), xdist=1, ydist=1, save.chain=TRUE)
```

We can plot the enhanced cluster assignments as above.
```{r enhance.plot, eval=TRUE, fig.width=7, fig.height=5}
ggplot(as.data.frame(colData(enhanced)), aes(x = col, y = row, fill = factor(spatial.cluster))) +
  geom_point(size = 2.5, pch = 22) +
  labs(x = NULL, y = NULL, fill = "Cluster") +
  scale_fill_manual(values = c("purple", "red", "blue", "yellow")) +
  theme_void() + 
  coord_fixed()
```

Note that the enhanced PCs are stored as a `reducedDim` and the enhanced
SingleCellExperiment has no assays. To impute expression (or other features) at
subspot resolution, we need to run `enhanceFeatures()` afterwards.

By default, log-normalized expression (`logcounts(sce)`) is imputed, but other
assays or arbitrary features can be specified.
```{r enhanceFeatures, eval=FALSE}
enhanced <- enhanceFeatures(enhanced, sce) 
```

TODO: add example of running SPOTlight and imputing proportion vectors

## Accessing Markov chains

If `save.chain` is set to `TRUE` in either `spatialCluster()` or
`spatialEnhance()`, the chain associated with the respective MCMC run is
preserved to disk as an HDF5 file. The path to this file is stored in the
SingleCellExperiment's metadata at `metadata(sce)$h5.chain`, and can be read
directly using `mcmcChain()`.

The chain is provided as a `coda::mcmc` object, which can be analyzed with
[TidyBayes](https://mjskay.github.io/tidybayes/) or as a matrix. The object has
one row per iteration, with the values of the parameters concatenated across the
row. Columns are named with the parameter name and index (if any).
```{r mcmcChain, eval=F}
chain <- mcmcChain(sce)
chain[1:5, 1:5]
```

To remove the HDF5 file from disk and remove its path from the metadata, use
`removeChain()`.
